use rusb::{UsbContext, Context, DeviceHandle, Direction, TransferType, request_type};
use std::time::Duration;

fn main() {
    let vid = 0x04f2; // Substitua pelo Vendor ID do teclado
    let pid = 0x0117; // Substitua pelo Product ID do teclado

    let context = Context::new().expect("Falha ao inicializar o contexto libusb");
    let handle: DeviceHandle<_> = context.open_device_with_vid_pid(vid, pid)
        .expect("Dispositivo não encontrado");

    // Reivindicar a interface correta (se necessário)
    handle.claim_interface(3).expect("Falha ao reivindicar a interface");

    // Substitua pelo pacote que você capturou no Wireshark
    let precommand_brightness = [0x08, 0x00, 0x33, 0x05, 0x00, 0x00, 0x00, 0xf5];
    let set_brightness = [8, 0, 51, 5, 12, 1, 1, 177];
    //let static_color = [0x08, 0x02, 0x33, 0x05, 0x19, 0x08, 0x01, 0x9b]; // Set static mode
    //let color = [0x12, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0xe5];

    /*[0x1c, 0x00, 0x60, 0xb6, 0x7d, 0x4c, 0x0b, 0xd0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x00,
    0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x21, 0x09, 0x00, 0x03,
    0x03, 0x00, 0x08, 0x00, 0x08, 0x02, 0x33, 0x05, 0x19, 0x08, 0x01, 0x9b]; */

    let precommand_effects:[u8;16] = [8, 2, 0, 0, 0, 0, 0, 245, 20, 0, 0, 255, 0, 0, 0, 0];
    let breath_effect:[u8;8] = [8, 0, 2, 1, 12, 1, 0, 224];
    let neon_effect:[u8;8] = [8, 0, 8, 5, 12, 1, 0, 221];
    let ripple_effect:[u8;8] = [8, 0, 6, 9, 12, 1, 1, 213];
    let snow_effect:[u8;8] = [8, 0, 40, 9, 12, 1, 0, 213];
    let snake_effect:[u8;8] = [8, 0, 5, 9, 12, 1, 0, 213];
    let wave_effect:[u8;8] = [8, 0, 3, 9, 12, 1, 5, 213];
    let lightning_effect:[u8;8] = [8, 0, 18, 14, 12, 1, 0, 213];
    let raindrop_effect:[u8;8] = [8, 0, 10, 9, 12, 1, 5, 213];
    let spot_effect:[u8;8] = [8, 0, 37, 9, 12, 1, 5, 213];
    let star_effect:[u8;8] = [8, 0, 38, 9, 12, 1, 5, 213];
    let fireball_effect:[u8;8] = [8, 0, 39, 9, 12, 1, 5, 213];
    let heartbeat_effect:[u8;8] = [8, 0, 41, 9, 12, 1, 5, 213];

    /*
        Wave directions:
            0,1 -> right
            2 -> left
            3 -> top
            4 -> bottom
            5 -> spin right
            6 -> spin left
     */
    // Estrutura dos efeitos [8, 0, tag, velocidade(diminui), brilho(aumenta), 1, wave directions, brilho(diminui)+velocidade(aumenta)]

    let precommand_color:[u8;8]= [0x12, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0xe5];

    // Effects max brightness: ultimo byte dessa vez comeca em 239 e vai diminuindo ate 189, enquanto que o outro byte vai aumentando ate 50.
    // O brilho dos efeitos animados [e] igual ao valor do byte de velocidade de animacao(variando de 1 a 9) mais o byte de brilho(variando de 193 a 243 com velocidade maxima(1))
    let mut color_type1= [0u8; 512];

    let mut i = 1;

    let ident_loc = [30, 34, 38, 58, 122, 146, 170, 194, 218, 266, 318, 350, 354, 366, 370, 374, 378, 390, 394, 454, 478, 486, 502];

    while i < color_type1.len()
    {
        if let Some(index) = ident_loc.iter().position(|&x| x == i){
            color_type1[i] = 0;
            color_type1[i+1] = 174;
            color_type1[i+2] = 199;
        }else{
            color_type1[i] = 133;
            color_type1[i+1] = 255;
            color_type1[i+2] = 150;
        }
        i += 4;
    }

    let set_color:[u8;8] = [0x8, 0x2, 0x33, 0x5, 0x32, 0x8, 0x1, 0x82];
   //let request_type = request_type(Direction::Out, rusb::RequestType::Class, rusb::Recipient::Interface);
    let timeout = Duration::from_secs_f64(0.01);

   // match handle.write_control(0x21, 0x09, 0x0300, 3, &precommand_color, timeout) {
   //     Ok(bytes) => println!("Enviado {} bytes", bytes),
   //     Err(e) => eprintln!("Erro ao enviar: {:?}", e),
   // }

    for i in 0..2{
        //println!("Index: {i}, Color_type Size: {}", &color_type1[i*64..(i+1)*64].len());
        match handle.write_control(0x21, 0x09, 0x0300, 3,&precommand_effects[i*8..(i+1)*8], timeout){
            Ok(bytes) => print!("Enviado {bytes} bytes"),
            Err(e) => eprint!("Erro ao enviar: {:?}", e),
        }
    }
    //std::thread::sleep(Duration::from_secs_f64(0.57));

    match handle.write_control(0x21, 0x09, 0x0300, 3, &raindrop_effect, timeout) {
        Ok(bytes) => println!("Enviado {} bytes", bytes),
        Err(e) => eprintln!("Erro ao enviar: {:?}", e),
    }
}


